//
//  DatabaseManager.swift
//  Coliving
//
//  Created by Andressa Aquino on 14/01/18.
//  Copyright Â© 2018 Andressa Aquino. All rights reserved.
//

import UIKit

import FirebaseDatabase

class DatabaseManager: NSObject {

	//FIRDatabaseReference for the root of Coliving's Firebase Database
	static var ref: DatabaseReference = Database.database().reference()

	private override init() {}

	///Checks connection with Firebase Database backend
	static func checkConnection(completionHandler: @escaping (Bool) -> Void) {
		let connectedRef = Database.database().reference(withPath: ".info/connected")

		connectedRef.observeSingleEvent(of: .value) {
			snapshot in
			if let connected = snapshot.value as? Bool, connected {
				print("Connected")
			} else {
				print("Not connected")
			}
		}
	}

	// MARK - Shopping List

	static func readShoppingDict(snapshot: DataSnapshot) -> [ShoppingItem]? {

		if let snapList = snapshot.children.allObjects as? [DataSnapshot]{

			guard (snapList.count != 0) else {
				print("No item found on Shoppint List on DB")
				return nil
			}

			var shoppingList = [ShoppingItem]()

			for i in snapList {

				/// shoppingDict = [
				/// 		"name" = itemName,
				///			"checked" = checkBoll
				///	]
				guard let shoppingDict = i.value as? [ String : AnyObject ] else {
					print("Error on fetching item`s dictionary on DB.")
					return nil
				}

				/// Catch the id autogenerated
				guard let itemId = i.key as? String else {
					print("Error on fetching item`s id on DB.")
					return nil
				}

				guard let itemName = shoppingDict["name"] as? String else {
					print("Error on fetching item`s name on DB.")
					return nil
				}

				guard let checked = shoppingDict["checked"] as? String  else {
					print("Error on fetching item`s checked boolean on DB.")
					return nil
				}

				var checkBool: Bool

				if checked == "false" {
					checkBool = false
				} else {
					checkBool = true
				}

				let shoppingItem = ShoppingItem(name: itemName, id: itemId, checked: checkBool)

				shoppingList.append(shoppingItem)
			}

			return shoppingList

		}

		return nil

	}

	static func fetchShoppingItem(completionHandler: @escaping([ShoppingItem]?) -> Void){

		let shoppingListRef = ref.child("ShoppingList")

		shoppingListRef.observeSingleEvent(of: .value) {
			(snapshot) in

			guard let shoppingList = DatabaseManager.readShoppingDict(snapshot: snapshot) else {
				print("Error on fetching shopping list from DB")
				completionHandler(nil)
				return
			}

			completionHandler(shoppingList)

		}

	}

	static func addObserverToShoppingItems(completionHandler: @escaping([ShoppingItem]?) -> Void){

		ref.child("ShoppingList").observe(.value) {
			(snapshot) in

			guard let shoppingList = DatabaseManager.readShoppingDict(snapshot: snapshot) else {
				print("Error on fetching shopping list from DB")
				completionHandler(nil)
				return
			}

			completionHandler(shoppingList)
		}
	}


	static func addShoppingItem(item: String, completionHandler: @escaping (String?, Error?) -> Void){

		let childRef = ref.child("ShoppingList").childByAutoId()

		let shoppingDict: [String : String] = [
			"name": item,
			"checked": "false"
		]

		childRef.setValue(shoppingDict) {
			(error, _) in

			guard (error == nil) else {
				completionHandler(nil, error)
				return
			}

			let itemID = childRef.key

			completionHandler(itemID, nil)
		}

	}

	static func removeShoppingItem(item: ShoppingItem, completionHandler: @escaping(Error?) -> Void){

		let itemRef = ref.child("ShoppingList").child(item.id!)

		itemRef.removeValue {
			(error, _) in

			guard (error == nil) else {
				completionHandler(error)
				return
			}

			completionHandler(nil)
		}

	}

	static func changeCheckItemStatus(item: ShoppingItem, newStatus: String, completionHandler: @escaping(Error?) -> Void){

		let checkRef = ref.child("ShoppingList").child(item.id!).child("checked")

		checkRef.setValue(newStatus) {
			(error, _) in

			guard (error == nil) else {
				completionHandler(error)
				return
			}

			completionHandler(nil)
		}
	}

	// MARK: - Finances

	static func addFinanceTransaction(transaction: FinanceTransaction, completionHandler: @escaping(Error?) -> Void){

		let childRef = ref.child("FinanceList").childByAutoId()

		let dateFormatter = DateFormatter()
		dateFormatter.dateFormat = "dd/MM/yyyy"
		let dateString = dateFormatter.string(from: transaction.date)

		let financeDict: [String : Any] = [
				"title" : transaction.title,
				"name" : transaction.name,
				"category" : transaction.category.categoryName,
				"value" : String(transaction.value),
				"date": dateString
		]

		childRef.setValue(financeDict) {
			(error, _) in

			guard (error == nil) else {
				completionHandler(error)
				return
			}

			let itemID = childRef.key
			transaction.id = itemID

			completionHandler(nil)
		}

	}

	static func removeFinanceTransaction(transaction: FinanceTransaction, completionHandler: @escaping(Error?) -> Void) {

		let financesRef = ref.child("FinanceList").child(transaction.id!)

		financesRef.removeValue {
			(error, _) in

			guard (error == nil) else {
				completionHandler(error)
			return
			}

			completionHandler(nil)
		}

	}

	static func addObserverToFinancesList(completionHandler: @escaping([FinanceTransaction]?) -> Void){

		ref.child("FinanceList").observe(.value) {
			(snapshot) in

			guard let financesList = DatabaseManager.readFinancesDict(snapshot: snapshot) else {
				print("Error on fetching finances list from DB")
				completionHandler(nil)
				return
			}

			completionHandler(financesList)
		}
	}

	static func readFinancesDict(snapshot: DataSnapshot) -> [FinanceTransaction]? {

		if let snapList = snapshot.children.allObjects as? [DataSnapshot]{

			guard (snapList.count != 0) else {
				print("No item found on Finances List on DB")
				return nil
			}

			var financesList = [FinanceTransaction]()

			for i in snapList {

				/* financeDict = [
						"title" : transaction.title,
						"name" : transaction.name,
						"category" : transaction.category.categoryName,
						"value" : String(transaction.value),
						"date": "\(transaction.date)"
				]*/
				guard let financesDict = i.value as? [ String : AnyObject ] else {
					print("Error on fetching item`s dictionary on DB.")
					return nil
				}

				/// Catch the id autogenerated
				guard let itemId = i.key as? String else {
					print("Error on fetching item`s id on DB.")
					return nil
				}

				guard let title = financesDict["title"] as? String else {
					print("Error on fetching finances title on DB.")
					return nil
				}

				guard let name = financesDict["name"] as? String else {
					print("Error on fetching finances title on DB.")
					return nil
				}

				guard let categoryString = financesDict["category"] as? String else {
					print("Error on fetching finances title on DB.")
					return nil
				}

				guard let valueString = financesDict["value"] as? String else {
					print("Error on fetching finances title on DB.")
					return nil
				}

				guard let dateString = financesDict["date"] as? String else {
					print("Error on fetching finances title on DB.")
					return nil
				}

				let category = CategoryEnum.getCategory(category: categoryString)

				let value = Double(valueString)

				let dateFormatter = DateFormatter()
				dateFormatter.dateFormat = "dd/MM/yyyy"

				guard let date = dateFormatter.date(from: dateString) else {
					fatalError("ERROR: Date conversion failed due to mismatched format.")
				}

				let financeTransaction = FinanceTransaction(id: itemId, title: title, name: name, value: value!, category: category!, date: date)

				financesList.append(financeTransaction)
			}

			return financesList

		}

		return nil

	}
}
